Primero había empezado el código directamente, enfocándome en que el jugador pudiera saltar y que los obstáculos aparecieran en la pantalla. Sin embargo, en medio del proceso me di cuenta de que el código se estaba volviendo complicado de entender y mantener, porque no había una estructura clara. Todo estaba revuelto, y cualquier cambio generaba más trabajo del necesario. Así que, para organizarme mejor, decidí pausar el código y trabajar primero en un diagrama de clases que me ayudara a visualizar la estructura general del proyecto.

![Main1](https://github.com/user-attachments/assets/670bf4b7-7e2d-4cff-a156-eb3a98ee9217)

Elaborar el diagrama de clases me ayudo mucho. Esto me permitió entender cómo se iban a relacionar los distintos componentes del juego y ver cuáles atributos y métodos se repetían entre los elementos. Vi que tanto el jugador como los obstáculos necesitaban atributos básicos como la posición (x, y) y el tamaño (width, height). Esto me dio la idea de crear una clase base llamada GameObject, que almacenaría estos atributos comunes. Así, tanto el jugador como el obstáculo podrían heredar de esta clase, evitando tener que definir estos atributos repetidamente en cada clase individual. Con GameObject, el código se volvió más limpio y ordenado desde el diseño inicial, y cualquier cambio en los atributos compartidos podía hacerse directamente en esta clase base, reflejándose automáticamente en el jugador y los obstáculos.

![Main](https://github.com/user-attachments/assets/0161b2a0-c696-4c08-8cab-365ab38b4135)

Después de tener claro el diagrama, empecé a pasar el código a Programación Orientada a Objetos (POO). Fue un proceso de varios pasos. Primero, definí las estructuras de Player y Obstacle, cada una heredando de GameObject. Esto significaba que ya no tenía que duplicar los atributos de posición y tamaño en ambas clases; en cambio, al heredar de GameObject, ambas clases compartían esos mismos atributos, lo que redujo la repetición de código y evitó que cada clase tuviera que manejar la posición y tamaño de forma individual. Después, me enfoqué en agregar los atributos y métodos específicos de cada una: por ejemplo, para Player añadí el atributo vel_y para controlar su velocidad en el eje vertical, necesario para manejar el salto, y para Obstacle añadí vel_x para su movimiento horizontal.

Una vez organizadas las clases, empecé a implementar las funciones básicas del juego. Creé una función de inicialización para configurar la ventana del juego y el entorno gráfico necesario. Luego, añadí una función para procesar la entrada del usuario, de manera que al presionar la tecla de espacio, el jugador pudiera saltar. También agregué funciones para actualizar las posiciones de los objetos según el tiempo y la velocidad, y para renderizar los objetos en la pantalla en cada cuadro del ciclo del juego. Además, al final incluí una función para destruir la ventana y liberar los recursos gráficos al terminar el juego, asegurando que el programa liberara correctamente la memoria utilizada.

Mientras avanzaba, surgieron varios errores que me hicieron revisar y ajustar el código en varios puntos. Uno de los primeros errores fue con la variable global game_is_running, la cual controla el ciclo principal del juego y se usa para saber si el juego sigue activo o no. Al dividir el código en varios archivos y clases, game_is_running no estaba correctamente declarada en algunos archivos, por lo que el compilador no la reconocía en algunas funciones, y el programa simplemente no compilaba. Después de investigar un poco, me di cuenta de que tenía que ajustar cómo y dónde declaraba esta variable para asegurarme de que estuviera disponible en todas las funciones que la necesitaban. Hice los cambios necesarios en la estructura de los archivos, y una vez que game_is_running fue reconocida en todo el código, el problema de compilación se resolvió.

Otro problema significativo surgió en el proceso de renderizado. Al principio, la ventana del juego aparecía, pero estaba completamente en negro, y los objetos (jugador y obstáculos) no se dibujaban en pantalla. Revisando el flujo de renderizado, noté que había algunos errores en cómo estaba configurando el color y las posiciones de los objetos. Los valores no estaban actualizándose como esperaba, lo que hacía que nada se mostrara en la ventana. Tuve que revisar cada parte del código de renderizado y probar distintas configuraciones. Finalmente, logré que tanto el jugador como el obstáculo se dibujaran correctamente en pantalla. Al confirmar que ambos elementos se mostraban, me aseguré de que el jugador podía saltar y que el obstáculo se desplazaba en el eje horizontal.

También encontré problemas con la mecánica del salto del jugador y la implementación de la gravedad. Al principio, el jugador parecía quedarse "flotando" en el aire después de saltar. Esto pasaba porque no había una lógica clara que distinguiera entre el estado de salto y el estado de estar en el suelo. Para resolverlo, revisé las condiciones de is_jumping, que controla si el jugador está en el aire, y ajusté los valores para que is_jumping solo se activara cuando el jugador realmente estaba en el aire y se desactivara al tocar el suelo. Esto evitó que el jugador quedara flotando y logró una transición fluida entre los saltos y el suelo.

El proceso de pasar el código a POO y estructurarlo mejor con el diagrama fue fundamental para simplificar el desarrollo y reducir los errores. Usar la herencia con GameObject hizo mucho más fácil la creación de las clases Player y Obstacle, y redujo la cantidad de código repetido. Los errores que aparecieron me ayudaron a entender mejor cómo manejar variables globales en un entorno con múltiples archivos y cómo solucionar los errores de compilación que surgieron por la división en módulos. Con estos cambios, el código ahora es más ordenado y fácil de modificar para futuras mejoras, y he aprendido mucho sobre cómo planificar mejor antes de comenzar el desarrollo.
